      SOURCES.find(s => s.id === t.source)?.label || '',
      t.time_estimate ? `${t.time_estimate}m` : '',
      (t.description || '').replace(/[\n\r,]/g, ' '),
      t.created_at ? new Date(t.created_at).toLocaleDateString() : ''
    ])
    
    const csvContent = [headers, ...rows].map(row => 
      row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
    ).join('\n')
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
    const link = document.createElement('a')
    link.href = URL.createObjectURL(blob)
    link.download = `trackli-tasks-${new Date().toISOString().split('T')[0]}.csv`
    link.click()
  }
  
  // Download blank CSV template
  const downloadTemplate = () => {
    const headers = ['ID', 'Title', 'Project', 'Status', 'Critical', 'Due Date', 'Start Date', 'Assignee', 'Customer', 'Category', 'Effort', 'Source', 'Time Estimate', 'Description']
    // Add example row with * for new task
    const exampleRow = ['*', 'Example Task', projects[0]?.name || 'Project Name', 'todo', 'No', '', '', '', '', '', '', '', '30m', 'Task description here']
    
    const csvContent = [headers, exampleRow].map(row => 
      row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
    ).join('\n')
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
    const link = document.createElement('a')
    link.href = URL.createObjectURL(blob)
    link.download = 'trackli-template.csv'
    link.click()
  }
  
  // Import CSV
  const [importing, setImporting] = useState(false)
  const [importResult, setImportResult] = useState(null)
  const fileInputRef = useRef(null)
  
  const handleImportCSV = async (e) => {
    const file = e.target.files?.[0]
    if (!file) return
    
    setImporting(true)
    setImportResult(null)
    
    try {
      const text = await file.text()
      const lines = text.split('\n').filter(line => line.trim())
      
      if (lines.length < 2) {
        setImportResult({ error: 'CSV must have a header row and at least one data row' })
        setImporting(false)
        return
      }
      
      // Parse header
      const parseCSVLine = (line) => {
        const result = []
        let current = ''
        let inQuotes = false
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i]
          if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
              current += '"'
              i++
            } else {
              inQuotes = !inQuotes
            }
          } else if (char === ',' && !inQuotes) {
            result.push(current.trim())
            current = ''
          } else {
            current += char
          }
        }
        result.push(current.trim())
        return result
      }
      
      const headers = parseCSVLine(lines[0]).map(h => h.toLowerCase().trim())
      const idIndex = headers.indexOf('id')
      const titleIndex = headers.indexOf('title')
      const projectIndex = headers.indexOf('project')
      const statusIndex = headers.indexOf('status')
      const criticalIndex = headers.indexOf('critical')
      const dueDateIndex = headers.indexOf('due date')
      const startDateIndex = headers.indexOf('start date')
      const assigneeIndex = headers.indexOf('assignee')
      const customerIndex = headers.indexOf('customer')
      const categoryIndex = headers.indexOf('category')
      const effortIndex = headers.indexOf('effort')
      const sourceIndex = headers.indexOf('source')
      const timeEstimateIndex = headers.indexOf('time estimate')
      const descriptionIndex = headers.indexOf('description')
      
      if (titleIndex === -1) {
        setImportResult({ error: 'CSV must have a Title column' })
        setImporting(false)
